import numpy as np

A = np.array([
    [  2.0,   1.0,    2.0,     1.0    ],
    [  6.0,   0.0,    4.0,     0.5    ],
    [  2.5,   1.333,  0.6667,  0.693  ],
    [  4.4,   1.5,   -2.667,   2.0    ]
])

i, j = 1, 2  
n = A.shape[0]  

print("Исходная матрица A:")
print(A, "\n")

# Формируем E_i (1×n)
E_i = np.zeros((1, n))
E_i[0, i-1] = 1  # единственная 1 в позиции i-1

# Формируем E_j^T (n×1)
E_j = np.zeros((n, 1))
E_j[j-1, 0] = 1  # единственная 1 в позиции j-1

# Получаем i-ю строку умножением E_i*A
row_i_via_mult = E_i @ A
print(f"3.1.3.3: i-я строка (i={i}) через умножение:")
print(row_i_via_mult, "\n")

# Получаем j-й столбец умножением A*E_j
col_j_via_mult = A @ E_j
print(f"3.1.3.3: j-й столбец (j={j}) через умножение:")
print(col_j_via_mult, "\n")




ones_col = np.ones((n, 1))    # вектор из 1, размер n×1
ones_row = np.ones((1, n))    # вектор из 1, размер 1×n

sum_row_i = (E_i @ A @ ones_col)[0, 0]
sum_col_j = (ones_row @ A @ E_j)[0, 0]

print(f"3.1.3.4: Сумма элементов i-й строки (i={i}) =", sum_row_i)
print(f"3.1.3.4: Сумма элементов j-го столбца (j={j}) =", sum_col_j, "\n")


P = np.eye(n)
Q = np.eye(n)

# В P меняем местами строки i-1 и j-1
P[[i-1, j-1], :] = P[[j-1, i-1], :]

# В Q меняем местами столбцы i-1 и j-1
Q[:, [i-1, j-1]] = Q[:, [j-1, i-1]]

# Теперь умножим A слева на P (перестановка строк), а справа на Q (перестановка столбцов)
A_swapped = P @ A @ Q

print("3.1.3.5: Матрица A после перестановки i-й и j-й строк/столбцов:")
print(A_swapped)
