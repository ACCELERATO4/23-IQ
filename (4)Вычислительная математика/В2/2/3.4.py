import numpy as np

# 3.4.2.1 Установите режим автоматических вычислений
# В Python автоматические вычисления выполняются по умолчанию

# 3.4.2.2 Преобразуйте исходную систему Cx = d к виду x = b + Ax
# Дано: Cx = b, преобразуем к x = b + Ax, где C - диагональная матрица

# 3.4.2.3 Введите матрицы A и b
A = np.array([
    [200, -13, 12],
    [1, 400, 9],
    [-8, 8, 600]
], dtype=float)

b = np.array([-2470, 904, 7920], dtype=float)

# 3.4.2.4 Проверьте достаточное условие сходимости
# Проверка диагонального преобладания
for i in range(len(A)):
    diag_element = abs(A[i, i])
    sum_other_elements = sum(abs(A[i, j]) for j in range(len(A)) if j != i)
    if diag_element <= sum_other_elements:
        print("Предупреждение: диагонального преобладания нет, метод может не сойтись.")
        break

# 3.4.2.5 Определите нулевое (начальное) приближение решения
x_curr = np.zeros(3, dtype=float)  # Начальное приближение (0, 0, 0)

# 3.4.2.6 Задайте количество итераций и точность
max_iter = 100
tol = 1e-10

# 3.4.2.7 Введите формулу вычисления последовательных приближений решения и вычислите их
def iteration_step(x):
    """Один шаг метода Якоби."""
    x1 = (-2470 + 13*x[1] - 12*x[2]) / 200
    x2 = (904 - x[0] - 9*x[2]) / 400
    x3 = (7920 + 8*x[0] - 8*x[1]) / 600
    return np.array([x1, x2, x3])

# Итерационный процесс
for k in range(max_iter):
    x_next = iteration_step(x_curr)
    
    # Критерий остановки (проверка на малые изменения)
    if np.linalg.norm(x_next - x_curr, ord=np.inf) < tol:
        print(f"Метод сошелся за {k+1} итераций.")
        break

    x_curr = x_next

# Вывод результатов
print("Приближенное решение методом итераций (Якоби):")
print(x_curr)

# Сравнение с точным решением
x_exact = np.linalg.solve(A, b)
print("\nПроверка через numpy.linalg.solve (точное решение):")
print(x_exact)
